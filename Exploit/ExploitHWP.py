# External Import Module
from zlib import decompress
from traceback import format_exc

# Internal Import Module
from PE import CPE
from Common import CBuffer


class CExploitHWP():
    @classmethod
    def fnScanExploit(cls, l_HWPSSector):
        
        try :
            
            s_HWPSecName = l_HWPSSector[0]  # Short-Sector Name
            s_HWPSecData = l_HWPSSector[1]  # Short-Sector Data
            
            ExploitHWP = CExploitHWP()
            
            # Type 1. BOF - Just in "Section"
            ExploitHWP.fnScanBOF(s_HWPSecName, s_HWPSecData)
            
            # Type 2. Embedded PE
            ExploitHWP.fnScanEmbedded(s_HWPSecName, s_HWPSecData)
            
        except :
            print format_exc()
            return False
        
        return True
    def fnScanBOF(self, s_HWPSecName, s_HWPSecData):
        
        try :
            
            for s_Sector in enumerate( s_HWPSecName ) :
                if s_Sector[1].find("Sector") == 0 :
                    n_TagID = self.fnExploitBOF(s_HWPSecName[ s_Sector[0] ], s_HWPSecData[ s_Sector[1] ] )
                    if n_TagID == False :
                        print "[-] Error - fnExploitBOF(%s)" % s_HWPSecName[ s_Sector[0] ]
                        return False
                    if n_TagID != None :
                        print "[*] Vulnerabiliry : %s - 0x%02X [ %s ]" % (s_HWPSecName[ s_Sector[0] ], n_TagID, HWPTAG[n_TagID])
                        continue
            
        except :
            print format_exc()
            return False
        
        return True
    def fnExploitBOF(self, s_Name, s_Data):
        n_TagID = None
        
        try :
            
            try :
                s_Decrypt = decompress( s_Data, -15 )
            except :
                s_Decrypt = s_Data
            
            n_Position = 0
            while n_Position < s_Decrypt.__len__() :
                n_Record = CBuffer.fnReadData(s_Decrypt, n_Position, 4)
                if n_Record == None :
                    print "[-] Error - fnReadData(%s, 0x%08X, 0x%08X, szRead : 4Bytes)" % (s_Name, n_Position, n_Record)
                    return False
                
                n_Position += 4
                n_TagID = n_Record & 0b1111111111
                # n_Level = (n_Record >> 10) & 0b1111111111
                n_Size = (n_Record >> 20) & 0b111111111111
                if n_Size == 0xfff :
                    n_Size = CBuffer.fnReadData(s_Decrypt, n_Position, 4)
                    n_Position += 4
                    
                n_Position += n_Size
            
            if n_Position == s_Decrypt.__len__() :
                return None
        
        except :
            print format_exc()
            return False
        
        return n_TagID
    def fnScanEmbedded(self, s_HWPSecName, s_HWPSecData):
        
        try :
            
            PE = CPE()
            for s_Sector in enumerate( s_HWPSecData ) :
                if PE.fnIsPE( s_Sector[1] ) == "PE" :
                    print "[*] Vulnerability : %s - Embedded PE" % s_HWPSecName[ s_Sector[0] ]
            
        except :
            print format_exc()
            return None
        
        return True
    

# TagID
HWPTAG_BEGIN = 0x010
# HWPINFO
HWPTAG = {HWPTAG_BEGIN      :"HWPTAG_DOCUMENT_PROPERTIES",
          HWPTAG_BEGIN+1    :"HWPTAG_ID_MAPPINGS",
          HWPTAG_BEGIN+2    :"HWPTAG_BIN_DATA",
          HWPTAG_BEGIN+3    :"HWPTAG_FACE_NAME",
          HWPTAG_BEGIN+4    :"HWPTAG_BORDER_FILL",
          HWPTAG_BEGIN+5    :"HWPTAG_CHAR_SHAPE",
          HWPTAG_BEGIN+6    :"HWPTAG_TAB_DEF",
          HWPTAG_BEGIN+7    :"HWPTAG_NUMBERING",
          HWPTAG_BEGIN+8    :"HWPTAG_BULLET",
          HWPTAG_BEGIN+9    :"HWPTAG_PARA_SHAPE",
          HWPTAG_BEGIN+10   :"HWPTAG_STYLE",
          HWPTAG_BEGIN+11   :"HWPTAG_DOC_DATA",
          HWPTAG_BEGIN+12   :"HWPTAG_DISTRIBUTE_DOC_DATA",
          HWPTAG_BEGIN+13   :"RESERVED",
          HWPTAG_BEGIN+14   :"HWPTAG_COMPATIBLE_DOCUMENT",
          HWPTAG_BEGIN+15   :"HWPTAG_LAYOUT_COMPATIBILITY",
          
          # BodyText 
          HWPTAG_BEGIN+50   :"HWPTAG_PARA_HEADER",
          HWPTAG_BEGIN+51   :"HWPTAG_PARA_TEXT",
          HWPTAG_BEGIN+52   :"HWPTAG_PARA_CHAR",
          HWPTAG_BEGIN+53   :"HWPTAG_PARA_LINE_SEG",
          HWPTAG_BEGIN+54   :"HWPTAG_PARA_RANGE_TAG",
          HWPTAG_BEGIN+55   :"HWPTAG_CTRL_HEADER",
          HWPTAG_BEGIN+56   :"HWPTAG_LIST_HEADER",
          HWPTAG_BEGIN+57   :"HWPTAG_PAGE_DEF",
          HWPTAG_BEGIN+58   :"HWPTAG_FOOTNOTE_SHAPE",
          HWPTAG_BEGIN+59   :"HWPTAG_PAGE_BORDER_FILL",
          HWPTAG_BEGIN+60   :"HWPTAG_SHAPE_COMPONENT",
          HWPTAG_BEGIN+61   :"HWPTAG_TABLE",
          HWPTAG_BEGIN+62   :"HWPTAG_SHAPE_COMPONENT_LINE",
          HWPTAG_BEGIN+63   :"HWPTAG_SHAPE_COMPONENT_RECTANGLE",
          HWPTAG_BEGIN+64   :"HWPTAG_SHAPE_COMPONENT_ELLIPSE",
          HWPTAG_BEGIN+65   :"HWPTAG_SHAPE_COMPONENT_ARC",
          HWPTAG_BEGIN+66   :"HWPTAG_SHAPE_COMPONENT_POLYGON",
          HWPTAG_BEGIN+67   :"HWPTAG_SHAPE_COMPONENT_CURVE",
          HWPTAG_BEGIN+68   :"HWPTAG_SHAPE_COMPONENT_OLE",
          HWPTAG_BEGIN+69   :"HWPTAG_SHAPE_COMPONENT_PICTURE",
          HWPTAG_BEGIN+70   :"HWPTAG_SHAPE_COMPONENT_CONTAINER",
          HWPTAG_BEGIN+71   :"HWPTAG_CTRL_DATA",
          HWPTAG_BEGIN+72   :"HWPTAG_EQEDIT",
          HWPTAG_BEGIN+73   :"RESERVED",
          HWPTAG_BEGIN+74   :"HWPTAG_SHAPE_COMPONENT_TEXTART",
          HWPTAG_BEGIN+75   :"HWPTAG_FORM_OBJECT",
          HWPTAG_BEGIN+76   :"HWPTAG_SHAPE",
          HWPTAG_BEGIN+77   :"HWPTAG_MEMO_LIST",
          
          # DocInfo          
          HWPTAG_BEGIN+78   :"HWPTAG_FORBIDDEN_CHAR",
          
          # BodyText
          HWPTAG_BEGIN+79   :"HWPTAG_CHART_DATA",
          HWPTAG_BEGIN+99   :"HWPTAG_SHAPE_COMPONENT_UNKNOWN" }
    
    
    